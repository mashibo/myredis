# SDS 与 C 字符串的区别
> ### 区别
> * 获取一个 SDS 长度的复杂度仅为 O(1)
> * SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性
     * 当对SDS进行修改的时候，API会预先检查当前空间是否满足要求，如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小
> * 减少修改字符串时带来的内存重分配次数 
     * 因为 C 字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作
     * 通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略

     
> ### 空间预分配
> *  需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间
    * SDS 的长度（也即是 len 属性的值）将小于 1 M，那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同
    * 如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间
    * 通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。

> ### 惰性空间释放     
> * 惰性空间释放用于优化 SDS 的字符串缩短操作，当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用
    * SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费

    
> ### 二进制安全
> * C 字符串中的字符必须符合某种编码， 字符串里面不能包含空字符【需要以空字符串结尾】，所以不能保存像图片、音频、视频、压缩文件这样的二进制数据。
    * SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据（保证数据在写入时是什么样的， 它被读取时就是什么样）
    * SDS数据保存为二进制或者文本

> ### 兼容部分 C 字符串函数
> * 虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例，使得可以重用c语言的库函数

     